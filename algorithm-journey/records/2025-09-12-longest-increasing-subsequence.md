- ## 刷题记录 — 最长递增子序列

  ### 1. 题目名称

  [最长递增子序列 (LeetCode 300)](https://leetcode.com/problems/longest-increasing-subsequence/)

  ------

  ### 2. 题目描述

  - 给你一个整数数组 `nums`，找到其中最长严格递增子序列的长度。

    **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
     例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

  ------

  ### 3. 解题思路

  1. **动态规划**

     - 这是一个典型的「最优子结构」问题，适合用 DP 解决。

     - 定义：`dp[i]` 表示 **以 `nums[i]` 结尾的最长递增子序列的长度**。

     - 状态转移：

       ```
       dp[i] = max(dp[j] + 1),  0 <= j < i 且 nums[j] < nums[i]
       ```

     - 初始值：每个元素本身都可以单独作为子序列，因此 `dp[i] = 1`。

     - 答案：整个数组的 LIS = `max(dp[i])`。

  2. **重叠子问题**

     - 计算 `dp[i]` 时，会反复用到 `dp[j] (j<i)` 的结果。
     - 通过 dp 数组缓存，避免重复计算。

  3. **最优子结构**

     - 如果要让 `nums[i]` 作为结尾，就必须接在某个比它小的 `nums[j]` 后面。
     - 于是最优子序列长度就依赖于 `dp[j]` 的最优解。

  ------

  ### 4. 关键点总结

  - **dp 数组的定义至关重要**：选择“以某个元素结尾”作为状态，才能保证子问题可以递推。
  - **转移方程**：遍历前面所有比当前小的元素，取最大值再 +1。
  - **整体答案**：不是 `dp[n-1]`，而是整个 `dp` 数组的最大值。
  - 本题是「子序列 DP 模板」的经典例子。

  ------

  ### 5. 代码实现（Java 示例）

  ```java
  class Solution {
      public int lengthOfLIS(int[] nums) {
          // dp[i] = 以 nums[i] 结尾的最长递增子序列长度
          int[] dp = new int[nums.length];
          Arrays.fill(dp, 1);
  
          for (int i = 0; i < nums.length; i++) {
              for (int j = 0; j < i; j++) {
                  if (nums[j] < nums[i]) {
                      dp[i] = Math.max(dp[i], dp[j] + 1);
                  }
              }
          }
          return Arrays.stream(dp).max().getAsInt();
      }
  }
  ```

  ------

  ### 6. 时间与空间复杂度

  - **时间复杂度**：O(n²)
    - 外层循环遍历 i，内层循环遍历 j。
  - **空间复杂度**：O(n)
    - 需要一个长度为 n 的 dp 数组。

  ------

  ### 7. 复盘与反思

  - 这道题是动态规划的入门经典，考察了：
    - 状态定义是否正确
    - 能否写出符合最优子结构的状态转移方程
  - 一开始容易误以为 `dp[i]` 表示 `[0..i]` 的 LIS，但那样无法递推。
  - 正确思路是：给状态加一个“结尾元素”，这样才能保证子问题之间有依赖关系。

  ------

  ### 8. 扩展与变形

  1. **二分优化解法**（O(n log n)）：
     - 用一个数组 `tails` 维护当前所有递增子序列的最小结尾，结合二分查找更新。
     - 空间复杂度 O(n)，比 O(n²) 解法更高效。
  2. **变形题**：
     - **最长非递减子序列**（允许相等，状态转移改成 `<=`）。
     - **求 LIS 的具体序列**（不仅要长度，还要恢复路径）。
     - **最长下降子序列**（转化思路类似）。
     - **俄罗斯套娃信封问题 (LeetCode 354)**：本质是 LIS 的二维版本。